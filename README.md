---
layout: default
---

# Work in Progress (WIP)

This README outlines my personal, curated learning path for diving really deep into (advanced [backend]) software engineering concepts and practices. It is meant as my companion in a year-long (and potentially career-long) journey of continuous learning and curiosity in backend software engineering. It's designed to foster a perpetual growth mindset, encouraging me to stay curious, and adaptable.

The concepts I am interested in might change over time. As a result, this learning plan is continuously updated, expanded, and refined to match my developing interests and the changing tech landscape. Feel free to copy, add, modify, or reprioritize topics as your own learning journey progresses!

Ready to dive in? [Skip ahead to the learning plan](#learning-plan)

## Motivation

- Maintain a consistent learning habit throughout your career
- Adapt to the ever-evolving landscape of backend engineering
- Cultivate curiosity and a passion for lifelong learning

## Usage

This learning plan is a living, breathing entity. It should grow and evolve with you throughout your career. Regularly update, expand, and refine it to match your developing interests and the changing tech landscape.

### Daily Learning Habit

1. ðŸŽ² Randomly (or decisively) select a topic from the list below.
2. ðŸ“š Dedicate 2 hours to exploring the chosen concept.
3. ðŸ’» Apply your new knowledge through practical coding or projects.
4. ðŸ¤” Reflect on how this knowledge fits into your broader engineering perspective.

### Optimal Approach

- Prioritize learning that directly applies to current or upcoming projects.
- Seek opportunities to implement new concepts in real-world scenarios (in other words, apply insights to real-world problems).
- If possible, align personal projects with learning goals and choose projects that you're excited about or that you have a need for.
- For work-related learning, focus on skills that add immediate value to your team or project.
- When facing decision paralysis, don't hesitate to choose randomly â€“ any learning is valuable.
- Deep dive into relevant topics, connecting them to your existing knowledge.
- Teach your learnings and share them with your community.
- Track progress, but remember: the journey of learning never truly ends.

### Progress and Reflection

- Use checkboxes to mark explored topics (notice how I don't like to say "completed" since you can always go down the rabbit hole for each and every one of the topics).
- Add brief notes or links to projects where you applied new concepts.
- Periodically reflect on your growth and how your perspective has evolved.

---

## Tips

### Prioritization and Focus

- Identify and always complete your #1 priority task first on time
- Use the "Make it work, make it right, make it fast" principle
  1. Create a solution that solves the problem
  2. Improve its structure and maintainability
  3. Optimize for performance if needed
- Embrace "done" over "perfect":
  - Strive for completion rather than perfection
  - A finished product can be improved, but an unfinished one provides no value
- Prioritize iterations over hours:
  - Aim for quick, iterative cycles rather than long, unbroken work sessions
  - This allows for regular feedback and improvement
- Use time-boxing techniques to maintain focus: allocate specific time slots for tasks to maintain focus and prevent perfectionism
- Balance deep work with iterative cycles
  - Engage in long, uninterrupted work sessions for complex tasks
  - Use these sessions to make significant progress on iterations
  - Follow Karpathy's advice on avoiding "snacking" and "eating the meal" (go deep, for hours at a time)
- Regularly review and adjust your process: Reflect on what's working and what isn't, and be willing to adapt your approach

### Problem-Solving and Unblocking

1. Define the Problem
   - Clearly identify what's blocking your progress
   - Break complex issues into smaller, manageable parts
2. Seek Solutions
   - Research existing solutions or similar problems
   - Use rubber duck debugging (explain the problem out loud)
   - Change your environment for a fresh perspective
3. Manage Your Approach
   - Time-box problem-solving attempts
   - Implement temporary workarounds when necessary
   - Use the "5 Whys" technique to find root causes
4. Leverage Resources
   - Seek help proactively (colleagues, mentors, online communities)
   - Pair program with a teammate when stuck
5. Document and Learn
   - Keep a log of blockers and how you overcame them
   - Treat blockers as learning opportunities
6. Stay Persistent
   - Maintain curiosity and persistence
   - View challenges as chances to grow your problem-solving abilities

### Workflow and Productivity
- Use the GTD (Getting Things Done) method:
  - Capture all tasks and ideas
  - Clarify actions required
  - Organize into categories
  - Regularly review and reflect
  - Take action
- Break large tasks into smaller steps
- Set clear, specific goals for each task or project
- Manage your "Waiting For" list effectively
- Create a functional, distraction-free workspace

---

## Learning Plan

Let the learning begin!

### Core Language and Tools

#### Go

- [ ] Conventions
  - [ ] Formatting
  - [ ] Commentary
    - [ ] Names
    - [ ] Package names
    - [ ] Getters
    - [ ] Interface names
    - [ ] MixedCaps
  - [ ] Semicolons
- [ ] Language Mechanics
  - [ ] Constants
  - [ ] Variables
  - [ ] The init function
  - [ ] Struct Types
  - [ ] Pointers
  - [ ] Control Structures
  - [ ] Functions
  - [ ] Arrays
  - [ ] Slices
  - [ ] Maps
  - [ ] Allocation with new
  - [ ] Constructors and composite literals
  - [ ] Allocation with make
  - [ ] Printing
  - [ ] Append
  - [ ] Methods
  - [ ] Interfaces
  - [ ] Embedding
  - [ ] Exporting
- [ ] The blank identifier
  - [ ] The blank identifier in multiple assignment
  - [ ] Unused imports and variables
  - [ ] Import for side effect
  - [ ] Interface checks
- [ ] Composition and Interfaces
  - [ ] Grouping with types
  - [ ] Type Conversions and assertions
  - [ ] Interface pollution
  - [ ] Mocking
  - [ ] Decoupling
  - [ ] Error handling
- [ ] Concurrency
  - [ ] Share by communicating
  - [ ] Goroutines
  - [ ] Data Races
  - [ ] Context Package
  - [ ] Channels
  - [ ] Channels of channels
  - [ ] Parallelization
  - [ ] A leaky buffer
  - [ ] Advanced concurrency patterns
- [ ] Generics
  - [ ] Basics
  - [ ] Underlying types
  - [ ] Struct types
  - [ ] Behavior as constraint
  - [ ] Type as constraint
  - [ ] Multi-type parameters
  - [ ] Slice constraints
  - [ ] Channels
  - [ ] Hash tables
- [ ] Errors
  - [ ] Panic
  - [ ] Recover
  - [ ] Error Handling
- [ ] Project Layout
- [ ] Design Patterns
- [ ] Go Idioms
- [ ] Going Deeper
  - [ ] Marshalling and unmarshalling JSON
  - [ ] Go scheduler
  - [ ] Go tooling
- [ ] Performance optimization techniques
- [ ] Go Modules and dependency management

#### Git

- [ ] Basic Git Commands
- [ ] Advanced Git Commands and Operations
  - [ ] Advanced `git log` usage (e.g., `--graph`, `--oneline`, custom formatting)
  - [ ] Cherry-picking commits
  - [ ] Using `git bisect` for bug hunting
  - [ ] Interactive rebase (`git rebase -i`)
- [ ] Branching Strategies
  - [ ] Git Flow workflow
  - [ ] GitHub Flow
  - [ ] Trunk-based development
  - [ ] Feature flags and their impact on branching
- [ ] Collaboration Techniques
  - [ ] Pull request workflows and best practices
  - [ ] Code review strategies using Git
  - [ ] Managing and resolving merge conflicts effectively
- [ ] Advanced Git Configurations
  - [ ] Global and local Git configurations
  - [ ] Customizing Git behavior with config options
- [ ] Git Security
  - [ ] Signing commits and tags with GPG
  - [ ] Best practices for securing Git repositories
- [ ] Submodules and Subtrees
  - [ ] When and how to use Git submodules
  - [ ] Managing projects with Git subtrees
- [ ] Git Worktrees
  - [ ] Understanding and utilizing multiple worktrees
- [ ] Git LFS (Large File Storage)
  - [ ] Setting up and using Git LFS for large binary files
- [ ] Git Hooks
  - [ ] Client-side hooks (pre-commit, prepare-commit-msg, etc.)
  - [ ] Server-side hooks (pre-receive, update, post-receive)
  - [ ] Writing custom Git hooks
- [ ] Git Automation and Scripting
  - [ ] Writing Git aliases for common workflows
  - [ ] Integrating Git with shell scripts
- [ ] Git in CI/CD Pipelines
  - [ ] Integrating Git with CI/CD tools (e.g., Jenkins, GitLab CI, GitHub Actions)
  - [ ] Git-centric Deployment Strategies
- [ ] Git Performance Optimization
  - [ ] Improving Git Performance for Large Repositories
  - [ ] Git Garbage Collection and Repository Maintenance
- [ ] Advanced Git Concepts
  - [ ] Git internals: objects, refs, and the DAG
  - [ ] Reflogs and how to use them for recovery
  - [ ] The stash: advanced usage and management

#### GitHub

- [ ] GitHub Basics
  - [ ] Creating and managing repositories
  - [ ] GitHub profile setup and customization
  - [ ] Using GitHub's web interface
- [ ] Collaboration on GitHub
  - [ ] Forking repositories
  - [ ] Creating and managing pull requests
  - [ ] Issue tracking and management
  - [ ] GitHub Projects for task management
- [ ] GitHub Actions
  - [ ] Understanding GitHub Actions workflow syntax
  - [ ] Creating custom actions
  - [ ] CI/CD pipelines with GitHub Actions
  - [ ] Using Actions for automation tasks
- [ ] GitHub Pages
  - [ ] Setting up GitHub Pages for projects
  - [ ] Custom domains with GitHub Pages
  - [ ] Using Jekyll with GitHub Pages
- [ ] GitHub Security Features
  - [ ] Dependabot for dependency management
  - [ ] Security advisories and vulnerability alerts
  - [ ] Code scanning with CodeQL
  - [ ] Secret scanning
- [ ] GitHub Packages
  - [ ] Publishing and managing packages
  - [ ] Integrating GitHub Packages with workflows
- [ ] GitHub API
  - [ ] Basic API usage and authentication
  - [ ] Integrating GitHub API in applications
  - [ ] Webhooks for real-time event handling
- [ ] GitHub Advanced Features
  - [ ] GitHub Codespaces
  - [ ] GitHub Copilot
  - [ ] GitHub Discussions
  - [ ] GitHub Sponsors
- [ ] GitHub for Team Collaboration
  - [ ] Organization management
  - [ ] Team structures and permissions
  - [ ] Code owners and CODEOWNERS file
- [ ] GitHub Enterprise
  - [ ] Differences between GitHub.com and GitHub Enterprise
  - [ ] Setting up and managing GitHub Enterprise
- [ ] GitHub Integrations
  - [ ] Integrating third-party tools and services
  - [ ] OAuth Apps vs. GitHub Apps
- [ ] GitHub Best Practices
  - [ ] Repository structure and organization
  - [ ] Documentation (README, CONTRIBUTING, CODE_OF_CONDUCT)
  - [ ] GitHub Flow workflow
- [ ] GitHub Analytics and Insights
  - [ ] Using GitHub Insights for repository analytics
  - [ ] Understanding and using GitHub traffic data
- [ ] Advanced GitHub Features
  - [ ] GitHub Actions environments and deployment
  - [ ] Managing large files with Git LFS on GitHub
  - [ ] GitHub CLI for command-line interactions
- [ ] GitHub Community and Open Source
  - [ ] Contributing to open source projects
  - [ ] Managing an open source project on GitHub
  - [ ] GitHub community guidelines and etiquette

#### PostgreSQL

- [ ] Installation and Setup
  - [ ] Using Package Managers
  - [ ] Using Docker for PostgreSQL
  - [ ] Connecting Using `psql`
  - [ ] Basic Configuration
- [ ] Managing PostgreSQL
  - [ ] Starting and Stopping PostgreSQL
    - [ ] Using `systemd`
    - [ ] Using `pg_ctl`
    - [ ] Using `pg_ctlcluster`
  - [ ] Creating and Managing Databases
  - [ ] User Management and Permissions
- [ ] Basic SQL and PostgreSQL Concepts
  - [ ] Data Types in PostgreSQL
  - [ ] Basic SQL Queries
    - [ ] SELECT, INSERT, UPDATE, DELETE
    - [ ] WHERE clauses and filtering
  - [ ] Table Creation and Modification
  - [ ] Indexing Basics
- [ ] Advanced SQL in PostgreSQL
  - [ ] JOINs and Set Operations
  - [ ] Subqueries and CTEs
  - [ ] Window Functions
  - [ ] Full-Text Search
  - [ ] JSON and JSONB Data Types
- [ ] PostgreSQL-Specific Features
  - [ ] PL/pgSQL for Stored Procedures
  - [ ] Triggers and Rules
  - [ ] Views and Materialized Views
  - [ ] Inheritance and Partitioning
- [ ] Database Design Principles
  - [ ] Normalization and Denormalization
  - [ ] Entity-Relationship Modeling
  - [ ] Constraints and Referential Integrity
- [ ] Performance Tuning
  - [ ] Query Optimization
  - [ ] EXPLAIN and ANALYZE
  - [ ] Index Types and When to Use Them
  - [ ] Vacuuming and Analyzing
- [ ] Transactions and Concurrency
  - [ ] ACID Properties in Practice
  - [ ] Transaction Isolation Levels
  - [ ] Handling Deadlocks
  - [ ] Multi-Version Concurrency Control (MVCC)
- [ ] Backup and Recovery
  - [ ] pg_dump and pg_restore
  - [ ] Point-in-Time Recovery
  - [ ] Continuous Archiving
- [ ] Replication and High Availability
  - [ ] Streaming Replication
  - [ ] Logical Replication
  - [ ] Failover and Switchover
- [ ] Security Best Practices
  - [ ] Authentication Methods
  - [ ] SSL Configuration
  - [ ] Row-Level Security
- [ ] Advanced PostgreSQL Features
  - [ ] Extensions (PostGIS, pgcrypto, etc.)
  - [ ] Full-Text Search Configuration
  - [ ] Foreign Data Wrappers
- [ ] PostgreSQL in Production
  - [ ] Deployment Strategies
  - [ ] Monitoring and Logging
  - [ ] Scaling PostgreSQL
- [ ] PostgreSQL and Application Development
  - [ ] Connecting from Various Programming Languages
  - [ ] ORMs and PostgreSQL
  - [ ] Connection Pooling
- [ ] Migrating to PostgreSQL
  - [ ] From Other Relational Databases
  - [ ] Data Import and Export Techniques
- [ ] PostgreSQL Internals
  - [ ] Write-Ahead Logging (WAL)
  - [ ] Buffer Management
  - [ ] Query Processing Pipeline
- [ ] Keeping Up-to-Date
  - [ ] Following PostgreSQL Releases
  - [ ] Community Resources and Contributions

#### Docker

- [ ] Fundamentals
  - [ ] Understanding virtualization concepts
  - [ ] Introduction to containerization
  - [ ] Differences between containers and virtual machines
- [ ] Docker Basics
  - [ ] Installing Docker
  - [ ] Docker architecture
  - [ ] Basic Docker commands (run, pull, push, etc.)
  - [ ] Working with Docker images
- [ ] Dockerfile
  - [ ] Writing Dockerfiles
  - [ ] Best practices for Dockerfile creation
  - [ ] Multi-stage builds
- [ ] Docker Containers
  - [ ] Container lifecycle management
  - [ ] Container networking
  - [ ] Volumes and data persistence
  - [ ] Container resource management
- [ ] Docker Compose
  - [ ] Writing docker-compose.yml files
  - [ ] Managing multi-container applications
  - [ ] Docker Compose commands and usage
- [ ] Docker Networking
  - [ ] Network types in Docker
  - [ ] Creating and managing custom networks
  - [ ] Container-to-container communication
- [ ] Docker Volumes
  - [ ] Types of Docker volumes
  - [ ] Volume management and backup strategies
  - [ ] Sharing data between containers and host
- [ ] Docker Security
  - [ ] Security best practices for Docker
  - [ ] Container isolation and resource constraints
  - [ ] Docker content trust and image signing
- [ ] Docker Swarm
  - [ ] Setting up a Docker Swarm cluster
  - [ ] Deploying services to Swarm
  - [ ] Swarm mode networking and load balancing
- [ ] Kubernetes Basics
  - [ ] Kubernetes architecture
  - [ ] Pods, Services, and Deployments
  - [ ] Basic Kubernetes commands with kubectl
- [ ] Advanced Docker Topics
  - [ ] Docker API and SDK usage
  - [ ] Custom Docker registry setup
  - [ ] Docker plugins and extensions
- [ ] Container Orchestration
  - [ ] Comparison of orchestration tools (Kubernetes, Docker Swarm, Nomad)
  - [ ] Choosing the right orchestration solution
- [ ] Monitoring and Logging
  - [ ] Container monitoring tools
  - [ ] Logging strategies for containerized applications
  - [ ] Using tools like Prometheus and Grafana
- [ ] CI/CD with Containers
  - [ ] Integrating Docker in CI/CD pipelines
  - [ ] Automated testing of Docker images
  - [ ] Continuous deployment strategies with containers
- [ ] Microservices and Containers
  - [ ] Designing microservices architecture
  - [ ] Implementing microservices with Docker
  - [ ] Service discovery and communication
- [ ] Container Storage
  - [ ] Persistent storage solutions for containers
  - [ ] Stateful applications in containers
- [ ] Windows Containers
  - [ ] Running Docker on Windows
  - [ ] Windows-specific container considerations
- [ ] Container Optimization
  - [ ] Optimizing Docker images for size and security
  - [ ] Performance tuning for containerized applications
- [ ] Serverless Containers
  - [ ] Introduction to serverless containers (e.g., AWS Fargate, Azure Container Instances)
  - [ ] Use cases and limitations
- [ ] Advanced Virtualization Concepts
  - [ ] Hypervisors and their types
  - [ ] Nested virtualization
  - [ ] Containerization vs. traditional virtualization trade-offs
- [ ] Emerging Container Technologies
  - [ ] Podman, Buildah, and other Docker alternatives
  - [ ] WebAssembly and its relation to containerization

#### Kubernetes

- [ ] Core Concepts
  - [ ] Pods, Services, and Deployments
  - [ ] ReplicaSets and StatefulSets
  - [ ] ConfigMaps and Secrets
  - [ ] Namespaces and Resource Quotas
- [ ] Kubernetes Architecture
  - [ ] Master and Worker Nodes
  - [ ] etcd, API Server, Scheduler, and Controller Manager
  - [ ] kubelet, kube-proxy, and Container Runtime
- [ ] Deployment Strategies
  - [ ] Rolling Updates
  - [ ] Blue/Green Deployments
  - [ ] Canary Deployments
  - [ ] A/B Testing
- [ ] Custom Resource Definitions (CRDs)
  - [ ] Creating and Managing CRDs
  - [ ] Extending Kubernetes API
  - [ ] Operators and the Operator Framework
- [ ] Kubernetes Networking
  - [ ] Service Types (ClusterIP, NodePort, LoadBalancer)
  - [ ] Ingress Controllers and Resources
  - [ ] Network Policies
- [ ] Storage in Kubernetes
  - [ ] Persistent Volumes and Persistent Volume Claims
  - [ ] Storage Classes
  - [ ] StatefulSets with Persistent Storage
- [ ] Kubernetes Security
  - [ ] Role-Based Access Control (RBAC)
  - [ ] Pod Security Policies
  - [ ] Network Policies for Security
- [ ] Monitoring and Logging
  - [ ] Prometheus and Grafana for Monitoring
  - [ ] ELK Stack for Logging
  - [ ] Kubernetes Dashboard
- [ ] Scaling and Performance
  - [ ] Horizontal Pod Autoscaler
  - [ ] Cluster Autoscaler
  - [ ] Vertical Pod Autoscaler
- [ ] Advanced Kubernetes Concepts
  - [ ] Helm for Package Management
  - [ ] Service Mesh (e.g., Istio)
  - [ ] Kubernetes Federation

#### CI/CD

- [ ] GitLab CI
  - [ ] GitLab CI/CD Pipeline Configuration
  - [ ] GitLab Runners
  - [ ] Job Artifacts and Caching
  - [ ] GitLab CI with Kubernetes
  - [ ] GitLab CI for Docker Image Building
- [ ] GitHub Actions
  - [ ] Workflow Syntax for GitHub Actions
  - [ ] Creating Custom Actions
  - [ ] GitHub-Hosted Runners vs Self-Hosted Runners
  - [ ] Secrets and Environment Variables in GitHub Actions
  - [ ] Matrix Builds
- [ ] Infrastructure as Code (IaC)
  - [ ] Terraform
    - [ ] Terraform Basics (Resources, Providers, State)
    - [ ] Writing Terraform Configurations
    - [ ] Terraform Modules
    - [ ] Remote State Management
    - [ ] Terraform Workspaces
  - [ ] CloudFormation (for AWS)
  - [ ] Azure Resource Manager Templates (for Azure)
- [ ] Continuous Integration Practices
  - [ ] Automated Testing in CI Pipelines
  - [ ] Code Quality Checks (Linting, Static Analysis)
  - [ ] Security Scanning in CI
- [ ] Continuous Deployment/Delivery
  - [ ] Deployment Strategies in CD
  - [ ] Feature Flags
  - [ ] Rollback Strategies
  - [ ] Blue/Green and Canary Deployments in Practice
- [ ] CI/CD Best Practices
  - [ ] Pipeline as Code
  - [ ] Immutable Infrastructure
  - [ ] Secrets Management in CI/CD
  - [ ] Monitoring and Observability in CD
- [ ] CI/CD for Microservices
  - [ ] Service-Specific Pipelines
  - [ ] Integration Testing for Microservices
  - [ ] Deployment Orchestration
- [ ] DevOps Metrics and KPIs
  - [ ] Deployment Frequency
  - [ ] Lead Time for Changes
  - [ ] Mean Time to Recovery (MTTR)
  - [ ] Change Failure Rate
- [ ] Advanced CI/CD Topics
  - [ ] GitOps Principles and Tools
  - [ ] CI/CD for Machine Learning Projects
  - [ ] CI/CD in Highly Regulated Environments

#### Visual Studio Code (VS Code)

- [ ] Installation and Setup
  - [ ] Download and install VS Code
  - [ ] Initial configuration
  - [ ] Setting up language support
- [ ] Basic Features
  - [ ] User Interface Overview
  - [ ] Command Palette (â‡§âŒ˜P / Ctrl+Shift+P)
  - [ ] Keyboard Shortcuts
  - [ ] Customizing Themes and Icons
  - [ ] Extensions and Marketplace
- [ ] Code Editing
  - [ ] IntelliSense and Autocompletion
  - [ ] Multi-cursor Editing
  - [ ] Snippets
  - [ ] Emmet for HTML and CSS
- [ ] Source Control Integration
  - [ ] Git Integration
  - [ ] Using GitLens Extension
  - [ ] Managing Branches and Commits
  - [ ] Viewing Diffs and History
- [ ] Debugging
  - [ ] Setting Breakpoints
  - [ ] Using the Debugger
  - [ ] Debugging Configurations for Different Languages
  - [ ] Live Share for Collaborative Debugging
- [ ] Productivity Tips
  - [ ] Quick Open (âŒ˜P / Ctrl+P)
  - [ ] Go to Definition and Peek Definition
  - [ ] Refactoring Tools
  - [ ] Code Navigation (Symbols, Files, Lines)
  - [ ] Integrated Terminal
- [ ] Customization
  - [ ] Customizing Keyboard Shortcuts
  - [ ] Settings and JSON Configuration
  - [ ] Creating and Using Workspace Settings
- [ ] Advanced Features
  - [ ] Remote Development (SSH, Containers, WSL)
  - [ ] Working with Jupyter Notebooks
  - [ ] Task Automation with Tasks.json
  - [ ] Using VS Code for DevOps (Docker, Kubernetes)
- [ ] Extensions for Enhanced Productivity
  - [ ] Prettier for Code Formatting
  - [ ] ESLint for Linting
  - [ ] Live Server for Web Development
  - [ ] REST Client for API Testing
  - [ ] Docker Extension
- [ ] Learning Resources
  - [ ] Interactive Editor Playground
  - [ ] VS Code Tips and Tricks
  - [ ] Official Documentation and Tutorials
  - [ ] Community Blogs and Videos

#### Vim

- [ ] Basic Navigation and Modes
  - [ ] Normal, Insert, and Visual modes
  - [ ] Moving the cursor (h, j, k, l, w, b, 0, $, etc.)
  - [ ] Page navigation (Ctrl+f, Ctrl+b, gg, G)
- [ ] Text Editing
  - [ ] Basic editing (i, a, o, x, d, y, p)
  - [ ] Undo and redo (u, Ctrl+r)
  - [ ] Repeating commands (.)
- [ ] Search and Replace
  - [ ] Searching in a file (/, ?, n, N)
  - [ ] Find and replace (:s, :%s)
  - [ ] Regular expressions in Vim
- [ ] Working with Multiple Files
  - [ ] Buffers, windows, and tabs
  - [ ] Splitting windows (:split, :vsplit)
  - [ ] Navigating between splits (Ctrl+w + h/j/k/l)
- [ ] Advanced Editing
  - [ ] Text objects (iw, aw, is, as, etc.)
  - [ ] Macros (q, @)
  - [ ] Marks (m, ')
- [ ] Customization
  - [ ] .vimrc configuration
  - [ ] Installing and using plugins (with a plugin manager like Vim-Plug)
- [ ] Vim-specific Features
  - [ ] Folding code
  - [ ] Completion (Ctrl+n, Ctrl+p)
  - [ ] Ctags for code navigation
- [ ] Vim in IDEs and Editors
  - [ ] Vim emulation in VS Code, IntelliJ, etc.
- [ ] Advanced Vim
  - [ ] Vim scripting basics
  - [ ] Creating custom commands and mappings

#### Bash and Command Line

- [ ] Bash Basics
  - [ ] Navigating the file system (cd, ls, pwd)
  - [ ] File operations (cp, mv, rm, mkdir)
  - [ ] Viewing file contents (cat, less, head, tail)
  - [ ] File permissions (chmod, chown)
- [ ] Bash Scripting
  - [ ] Variables and environment variables
  - [ ] Control structures (if, for, while)
  - [ ] Functions
  - [ ] Command substitution
  - [ ] Input/Output redirection and pipes
- [ ] Text Processing
  - [ ] grep and regular expressions
  - [ ] sed for stream editing
  - [ ] awk for data extraction and reporting
- [ ] Process Management
  - [ ] ps, top for viewing processes
  - [ ] kill, pkill for terminating processes
  - [ ] Job control (bg, fg, &)
- [ ] Networking Tools
  - [ ] ssh for secure connections
  - [ ] scp and rsync for file transfer
  - [ ] curl and wget for downloading
  - [ ] netstat and ss for network statistics
- [ ] System Monitoring
  - [ ] df, du for disk usage
  - [ ] free for memory usage
  - [ ] iotop for I/O monitoring
- [ ] Version Control from Command Line
  - [ ] git commands (clone, add, commit, push, pull)
  - [ ] Managing branches and merges
- [ ] Package Management
  - [ ] apt (Debian/Ubuntu) or yum/dnf (Red Hat/CentOS)
  - [ ] Compiling from source (configure, make, make install)
- [ ] Bash Customization
  - [ ] .bashrc and .bash_profile
  - [ ] Creating aliases and functions
  - [ ] Customizing the prompt (PS1)
- [ ] Advanced Bash Features
  - [ ] Command history and search
  - [ ] Tab completion
  - [ ] Brace expansion and globbing

#### Other Command Line Tools

- [ ] Text Editors
  - [ ] nano for quick edits
  - [ ] emacs basics
- [ ] Version Control
  - [ ] tig for Git text-mode interface
- [ ] File Compression
  - [ ] tar for archiving
  - [ ] gzip, bzip2 for compression
- [ ] Finding Files and Content
  - [ ] find for locating files
  - [ ] locate for quick file lookup
- [ ] Remote Management
  - [ ] tmux for terminal multiplexing
  - [ ] screen as an alternative to tmux
- [ ] System Administration
  - [ ] systemctl for service management
  - [ ] journalctl for log viewing
- [ ] Data Processing
  - [ ] jq for JSON processing
  - [ ] csvkit for CSV manipulation
- [ ] Network Diagnostics
  - [ ] ping, traceroute for network troubleshooting
  - [ ] nmap for network discovery and security auditing
- [ ] Performance Analysis
  - [ ] strace for system call monitoring
  - [ ] perf for performance analysis
- [ ] Security Tools
  - [ ] openssl for cryptography tasks
  - [ ] ssh-keygen for SSH key management
- [ ] Shell Alternatives and Enhancements
- [ ] zsh and Oh My Zsh
- [ ] fish shell
- [ ] PowerShell (for Windows environments)
- [ ] Command Line Productivity
- [ ] Keyboard shortcuts in Bash
- [ ] Creating and using shell scripts
- [ ] Configuring dotfiles
- [ ] Using a dotfiles manager (e.g., GNU Stow)

#### Amazon Web Services (AWS)

- [ ] AWS Fundamentals
  - [ ] AWS Global Infrastructure
  - [ ] AWS Regions and Availability Zones
  - [ ] AWS Edge Locations and Regional Edge Caches
- [ ] Core AWS Services
  - [ ] Compute
    - [ ] EC2 (Elastic Compute Cloud)
    - [ ] Lambda
    - [ ] ECS (Elastic Container Service)
    - [ ] EKS (Elastic Kubernetes Service)
  - [ ] Storage
    - [ ] S3 (Simple Storage Service)
    - [ ] EBS (Elastic Block Store)
    - [ ] EFS (Elastic File System)
    - [ ] Glacier
  - [ ] Database
    - [ ] RDS (Relational Database Service)
    - [ ] DynamoDB
    - [ ] Aurora
    - [ ] Redshift
  - [ ] Networking
    - [ ] VPC (Virtual Private Cloud)
    - [ ] Route 53
    - [ ] CloudFront
    - [ ] ELB (Elastic Load Balancing)
- [ ] Security and Identity
  - [ ] IAM (Identity and Access Management)
  - [ ] AWS Organizations
  - [ ] AWS Shield
  - [ ] AWS WAF (Web Application Firewall)
- [ ] Management and Governance
  - [ ] CloudWatch
  - [ ] CloudTrail
  - [ ] AWS Config
  - [ ] AWS Systems Manager
- [ ] AWS Pricing and Billing
  - [ ] AWS Free Tier
  - [ ] EC2 Pricing Models
  - [ ] S3 Pricing
  - [ ] Data Transfer Costs
  - [ ] AWS Budgets and Cost Explorer

#### AWS Certified Cloud Practitioner (CCP) Preparation

- [ ] Understanding the Exam
  - [ ] Exam format and structure
  - [ ] Exam domains and their weightings
  - [ ] Passing score and certification validity
- [ ] Cloud Concepts (26% of exam)
  - [ ] Define the AWS Cloud and its value proposition
  - [ ] Identify aspects of AWS Cloud economics
  - [ ] Explain the different cloud architecture design principles
- [ ] Security and Compliance (25% of exam)
  - [ ] Define the AWS Shared Responsibility model
  - [ ] Define AWS Cloud security and compliance concepts
  - [ ] Identify AWS access management capabilities
  - [ ] Identify resources for security support
- [ ] Technology (33% of exam)
  - [ ] Define methods of deploying and operating in the AWS Cloud
  - [ ] Define the AWS global infrastructure
  - [ ] Identify the core AWS services
  - [ ] Identify resources for technology support
- [ ] Billing and Pricing (16% of exam)
  - [ ] Compare and contrast the various pricing models for AWS
  - [ ] Recognize the various account structures in relation to AWS billing and pricing
  - [ ] Identify resources available for billing support
- [ ] Exam Preparation Strategies
  - [ ] Review AWS whitepapers and FAQs
  - [ ] Take AWS provided sample questions
  - [ ] Use practice exams from reputable sources
  - [ ] Hands-on experience with AWS Free Tier
- [ ] Final Preparation
  - [ ] Review exam readiness checklist
  - [ ] Schedule and take the exam
- [ ] Hands-on Projects
  - [ ] Deploy a static website on S3
  - [ ] Create a simple Lambda function
  - [ ] Set up a VPC with public and private subnets
  - [ ] Launch an EC2 instance and connect to it
  - [ ] Create and query a DynamoDB table
  - [ ] Set up CloudWatch alarms for EC2 instances
- [ ] Additional AWS Learning
  - [ ] AWS Well-Architected Framework
  - [ ] AWS Cloud Adoption Framework
  - [ ] AWS Trusted Advisor
  - [ ] AWS Professional Services and Partner Network

#### Google Cloud Platform (GCP) Fundamentals

- [ ] GCP Global Infrastructure
  - [ ] Regions and Zones
  - [ ] Edge Locations
- [ ] GCP Resource Hierarchy
  - [ ] Organizations
  - [ ] Folders
  - [ ] Projects
  - [ ] Resources
- [ ] Core GCP Services
  - [ ] Compute
    - [ ] Compute Engine (VMs)
    - [ ] Google Kubernetes Engine (GKE)
    - [ ] App Engine
    - [ ] Cloud Functions
    - [ ] Cloud Run
  - [ ] Storage
    - [ ] Cloud Storage
    - [ ] Persistent Disk
    - [ ] Filestore
  - [ ] Databases
    - [ ] Cloud SQL
    - [ ] Cloud Spanner
    - [ ] Cloud Bigtable
    - [ ] Firestore
  - [ ] Networking
    - [ ] Virtual Private Cloud (VPC)
    - [ ] Cloud Load Balancing
    - [ ] Cloud CDN
    - [ ] Cloud DNS
- [ ] Big Data and Analytics
  - [ ] BigQuery
  - [ ] Dataflow
  - [ ] Dataproc
  - [ ] Pub/Sub
  - [ ] Data Studio
- [ ] Machine Learning and AI
  - [ ] Vertex AI
  - [ ] Vision AI
  - [ ] Natural Language AI
  - [ ] Translation AI
  - [ ] Speech-to-Text and Text-to-Speech
- [ ] DevOps and Development Tools
  - [ ] Cloud Source Repositories
  - [ ] Cloud Build
  - [ ] Container Registry
  - [ ] Cloud Deployment Manager
- [ ] Security and Identity
  - [ ] Cloud Identity and Access Management (IAM)
  - [ ] Cloud Security Command Center
  - [ ] Cloud Key Management Service
  - [ ] Cloud Identity-Aware Proxy
- [ ] Management Tools
  - [ ] Cloud Console
  - [ ] Cloud Shell
  - [ ] Cloud SDK (gcloud)
  - [ ] Cloud Monitoring
  - [ ] Cloud Logging
- [ ] GCP Pricing and Billing
  - [ ] GCP Free Tier
  - [ ] Pricing Calculator
  - [ ] Billing Accounts and Budgets
- [ ] GCP Best Practices
  - [ ] Google Cloud Architecture Framework
  - [ ] Well-Architected Framework for GCP
- [ ] Hands-on Projects
  - [ ] Deploy a web application on App Engine
  - [ ] Set up a Kubernetes cluster with GKE
  - [ ] Create a data pipeline with Dataflow
  - [ ] Build a machine learning model with Vertex AI
  - [ ] Implement a CI/CD pipeline with Cloud Build
- [ ] GCP Certifications Preparation
  - [ ] Google Cloud Certified Associate Cloud Engineer
  - [ ] Google Cloud Certified Professional Cloud Architect
  - [ ] Google Cloud Certified Professional Data Engineer
- [ ] Advanced GCP Topics
  - [ ] Hybrid and Multi-cloud with Anthos
  - [ ] Cloud Interconnect and VPN
  - [ ] Cloud Composer (managed Apache Airflow)
  - [ ] Cloud Healthcare API
  - [ ] IoT Core
- [ ] GCP for Specific Industries
  - [ ] GCP for Gaming
  - [ ] GCP for Financial Services
  - [ ] GCP for Healthcare and Life Sciences
  - [ ] GCP for Retail

### "System Knowledge"

#### Operating Systems

- [ ] Fundamentals
  - [ ] Operating System Architecture and Components
  - [ ] Kernel and User Space
  - [ ] System Calls
- [ ] Process Management
  - [ ] Process States and Lifecycle
  - [ ] Threads and Multithreading
  - [ ] Inter-process Communication (IPC)
- [ ] Memory Management
  - [ ] Virtual Memory
  - [ ] Paging and Segmentation
  - [ ] Memory Allocation and Deallocation
- [ ] File Systems
  - [ ] File System Structures
  - [ ] Journaling File Systems
  - [ ] Distributed File Systems
- [ ] I/O Management
  - [ ] Device Drivers
  - [ ] Interrupt Handling
  - [ ] DMA (Direct Memory Access)
- [ ] Process Scheduling
  - [ ] Scheduling Algorithms
  - [ ] Priority Scheduling
  - [ ] Real-time Scheduling

#### Networking

- [ ] Internet Fundamentals
  - [ ] How the Internet Works
  - [ ] DNS and Domain Name Resolution
  - [ ] IP Addressing and Subnetting
- [ ] TCP/IP Stack
  - [ ] Application Layer Protocols
  - [ ] Transport Layer (TCP vs UDP)
  - [ ] Network Layer and Routing
  - [ ] Link Layer and MAC Addresses
- [ ] HTTP and HTTPS
  - [ ] HTTP/1.1 Basics
  - [ ] HTTP/2 Features and Improvements
  - [ ] HTTP/3 and QUIC Protocol
- [ ] WebSockets
  - [ ] WebSocket Protocol
  - [ ] Use Cases and Implementation
- [ ] Network Security
  - [ ] SSL/TLS
  - [ ] VPNs and Tunneling
  - [ ] Firewalls and Intrusion Detection Systems

#### Web Servers

- [ ] Web Server Architecture
- [ ] Popular Web Servers (Apache, Nginx, IIS)
- [ ] Reverse Proxies and Load Balancers
- [ ] Server-side Caching Mechanisms

#### Search Engines

  - [ ] Search Engine Architecture
  - [ ] Indexing and Crawling
  - [ ] Ranking Algorithms
  - [ ] Query Processing and Optimization

#### Real-time Data

- [ ] Server-Sent Events (SSE)
  - [ ] SSE protocol
  - [ ] Implementation and Use Cases
- [ ] WebSockets
  - [ ] Full-duplex Communication
  - [ ] Scaling WebSocket Applications
- [ ] Long Polling
  - [ ] Implementation Techniques
  - [ ] Advantages and Disadvantages
- [ ] Short Polling
  - [ ] Implementation and Use Cases
  - [ ] Comparison With Other Real-time Techniques

#### Distributed Systems

- [ ] Fundamentals
  - [ ] Distributed System Architectures
  - [ ] Challenges in Distributed Systems
- [ ] Consensus Algorithms
  - [ ] Raft Consensus Algorithm
  - [ ] Paxos Consensus Algorithm
  - [ ] Byzantine Fault Tolerance
- [ ] CAP Theorem
  - [ ] Consistency, Availability, Partition Tolerance
  - [ ] Implications and Trade-offs
- [ ] Distributed Data Storage
  - [ ] Distributed Databases
  - [ ] Data Replication and Sharding
- [ ] Distributed Computing
  - [ ] MapReduce Paradigm
  - [ ] Distributed File Systems (e.g., HDFS)

#### Security

- [ ] Authentication and Authorization
  - [ ] OAuth 2.0 Framework
  - [ ] OpenID Connect
  - [ ] JWT (JSON Web Tokens)
- [ ] Public Key Infrastructure (PKI)
  - [ ] Digital Certificates
  - [ ] Certificate Authorities
  - [ ] SSL/TLS Handshake
- [ ] Common Vulnerabilities and Mitigations
  - [ ] OWASP Top 10
  - [ ] Cross-Site Scripting (XSS)
  - [ ] SQL Injection
  - [ ] CSRF (Cross-Site Request Forgery)
- [ ] Encryption
  - [ ] Symmetric vs Asymmetric Encryption
  - [ ] Hashing and Salting
- [ ] Network Security
  - [ ] Firewalls and IDS/IPS
  - [ ] VPNs and Secure Tunnels

#### Databases

- [ ] Relational Databases
  - [ ] ACID properties
  - [ ] Indexing and Query Optimization
- [ ] NoSQL Databases
  - [ ] Types: Document, Key-Value, Column-family, Graph
  - [ ] CAP Theorem in NoSQL Context
- [ ] Database Transactions
  - [ ] Transaction Isolation Levels
  - [ ] Distributed Transactions

#### Caching

- [ ] Cache Levels (CPU cache, disk cache, etc.)
- [ ] Caching Strategies
- [ ] Distributed Caching Systems (e.g., Redis, Memcached)

#### Containerization and Virtualization

- [ ] Container Technologies (e.g., Docker)
- [ ] Virtual Machines vs Containers
- [ ] Orchestration (e.g., Kubernetes)

#### Cloud Computing

- [ ] Service Models (IaaS, PaaS, SaaS)
- [ ] Cloud Storage Systems
- [ ] Serverless Computing

#### Monitoring and Logging

- [ ] Log Aggregation and Analysis
- [ ] System and Application Monitoring
- [ ] Alerting and Incident Response

### System Design and Architecture

#### Fundamentals

- [ ] Basic principles of system design
- [ ] Scalability, reliability, and maintainability
- [ ] Trade-offs in system design

#### Architectural Patterns

- [ ] Monolithic architecture
- [ ] Microservices architecture
- [ ] Service-oriented architecture (SOA)
- [ ] Event-driven architecture
- [ ] Serverless architecture
- [ ] Twelve Factor Apps

#### Design and Development Principles

- [ ] GOF Design Patters
- [ ] Domain Driven Design
- [ ] Test Driven Development
- [ ] CQRS
- [ ] Event Sourcing

#### Microservices

- [ ] Microservices design principles
- [ ] Service discovery and registration
- [ ] API gateways
- [ ] Inter-service communication (sync vs async)
- [ ] Microservices security

#### Database Design

- [ ] Relational database design
- [ ] NoSQL Database Types and Use Cases
- [ ] ORMs
- [ ] ACID
- [ ] Transactions
- [ ] N+1 Problem
- [ ] Normalization and Denormalization
- [ ] Failure Modes
- [ ] Profiling Performance
- [ ] Database Indexing and Query Optimization
- [ ] Sharding Strategies
- [ ] NoSQL vs SQL trade-offs

#### Scalability Patterns (Building for Scale)

- [ ] Migration Strategies
  - [ ] Graceful Degradation
  - [ ] Throttling
  - [ ] Backpressure
  - [ ] Loadshifting
  - [ ] Circuit Breaker
- [ ] Types of Scaling
  - [ ] Horizontal Scaling
  - [ ] Vertical scaling
- [ ] Observability
- [ ] Difference & Usage
  - [ ] Instrumentation
  - [ ] Monitoring
  - [ ] Telemetry
- [ ] Caching
  - [ ] Servcer Side Caching Strategies (e.g., Redis, Memcached)
  - [ ] Client Side Caching Strategies
  - [ ] Load Balancing Techniques
  - [ ] Content Delivery Networks (CDNs)
- [ ] Database replication and partitioning

#### Distributed Systems

- [ ] CAP theorem
- [ ] Consistency models
- [ ] Distributed Consensus Algorithms (e.g., Paxos, Raft)
- [ ] Distributed Caching
- [ ] Distributed Transactions

#### Message Queues and Streaming

- [ ] Message Queue Architectures
- [ ] Kafka Architecture and Use Cases
- [ ] RabbitMQ and other AMQP implementations
- [ ] Stream Processing Patterns

#### API Design

- [ ] Fundamendals
  - [ ] REST
  - [ ] JSON
  - [ ] SOAP
  - [ ] gRPC
  - [ ] GraphQL
- [ ] RESTful API Design Principles
- [ ] GraphQL API Design
- [ ] API Versioning Strategies
- [ ] API Documentation (e.g., Swagger/OpenAPI)

#### Security in System Design

- [ ] Authentication and Authorization Patterns
  - [ ] Basic Authenticaton
  - [ ] Token Authentication
  - [ ] Cookie-based Authentication
  - [ ] JWT
  - [ ] OAuth
  - [ ] OpenID
  - [ ] SAML
- [ ] SSL/TLS and HTTPS
- [ ] OAuth and OpenID Connect
- [ ] Secure data storage and transmission

#### Monitoring and Observability

- [ ] Logging strategies
- [ ] Metrics and Monitoring Systems
- [ ] Distributed Tracing
- [ ] Alerting and On-call Systems

#### Performance Optimization

- [ ] Performance Testing Methodologies
- [ ] Identifying and Resolving Bottlenecks
- [ ] Optimizing application and Database Performance

#### Cloud Architecture

- [ ] Cloud Service Models (IaaS, PaaS, SaaS)
- [ ] Designing for Cloud-native Applications
- [ ] Multi-cloud and Hybrid Cloud Architectures

#### Containerization and Orchestration

- [ ] Docker in System Design
- [ ] Kubernetes Architecture and Concepts
- [ ] Service Mesh (e.g., Istio)

#### Data Processing Systems

- [ ] Batch Processing Systems
- [ ] Real-time Processing Systems
- [ ] Lambda and Kappa Architectures

#### Design Patterns

- [ ] Creational, Structural, and Behavioral Patterns
- [ ] Patterns for Distributed Systems
- [ ] Anti-patterns and when to avoid them

#### System Design Case Studies

- [ ] Designing a Social Media Platform
- [ ] Designing a Ride-sharing Service
- [ ] Designing a Distributed File Storage System

#### Design for Reliability

- [ ] Fault Tolerance and Graceful Degradation
- [ ] Disaster Recovery Strategies
- [ ] Chaos Engineering Principles

### Software Engineering Practices

#### Design Patterns

- [ ] Creational Patterns
  - [ ] Singleton, Factory, Abstract Factory
  - [ ] Builder, Prototype
- [ ] Structural Patterns
  - [ ] Adapter, Bridge, Composite
  - [ ] Decorator, Facade, Flyweight, Proxy
- [ ] Behavioral Patterns
  - [ ] Observer, Strategy, Command
  - [ ] State, Chain of Responsibility
  - [ ] Interpreter, Iterator, Mediator
  - [ ] Memento, Template Method, Visitor
- [ ] Architectural Patterns
  - [ ] MVC, MVVM, MVP
  - [ ] Repository Pattern
  - [ ] Dependency Injection
- [ ] Anti-patterns
  - [ ] Identifying common anti-patterns
  - [ ] Refactoring anti-patterns

#### Testing

- [ ] Test-Driven Development (TDD)
- [ ] Behavior-Driven Development (BDD)
- [ ] Unit Testing
- [ ] Integration Testing
- [ ] End-to-End Testing
- [ ] Property-based Testing
- [ ] Mutation Testing
- [ ] Performance Testing
- [ ] Load and Stress Testing
- [ ] Security Testing
- [ ] Mocking and Stubbing

#### Code Quality

- [ ] Clean Code Principles
- [ ] SOLID Principles
- [ ] DRY, KISS, and YAGNI principles
- [ ] Code Smells and how to address them
- [ ] Static Code Analysis
- [ ] Code Reviews Best Practices
- [ ] Pair Programming
- [ ] Refactoring Techniques
- [ ] Code Documentation

#### Debugging

- [ ] Debugging Techniques and Strategies
- [ ] Using Debuggers Effectively
- [ ] Log-based Debugging
- [ ] Remote Debugging
- [ ] Debugging Multithreaded Applications
- [ ] Memory Leak Detection and Resolution

#### Performance Optimization

- [ ] Profiling Tools and Techniques
- [ ] Algorithmic Optimization
- [ ] Database Query Optimization
- [ ] Caching Strategies
- [ ] Concurrency and Parallelism

#### Rapid Development and Prototyping

- [ ] Lean Software Development
  - [ ] Minimum Viable Product (MVP) concept
  - [ ] Build-Measure-Learn feedback loop
  - [ ] Eliminating waste in the development process
- [ ] Prototyping Techniques
  - [ ] Paper prototyping
  - [ ] Low-fidelity vs high-fidelity prototypes
  - [ ] Rapid prototyping tools
- [ ] Iterative Development
  - [ ] Incremental development strategies
  - [ ] Continuous user feedback integration
  - [ ] A/B testing for feature validation
- [ ] Time-boxing Techniques
  - [ ] Pomodoro Technique for focused work
  - [ ] Timeboxed spikes for research and exploration
- [ ] Fast Debugging in Development
  - [ ] Using REPL for quick testing
  - [ ] Hot reloading for instant feedback
  - [ ] Debugging by printf (strategic logging)
- [ ] Rapid Testing Strategies
  - [ ] Smoke testing for quick validation
  - [ ] Automated snapshot testing
  - [ ] Continuous testing in development
- [ ] Quick Deployment Techniques
  - [ ] Feature flags for gradual rollouts
  - [ ] Canary releases for real-world testing
  - [ ] Rolling updates for zero-downtime deployments
- [ ] Tools for Rapid Development
  - [ ] Code generators and scaffolding tools
  - [ ] No-code and low-code platforms
  - [ ] Rapid application development (RAD) frameworks

#### Version Control

- [ ] Effective Commit Messages
- [ ] Managing Large Repositories

#### Continuous Integration/Continuous Deployment (CI/CD)

- [ ] Setting up CI/CD Pipelines
- [ ] Automated Testing in CI/CD
- [ ] Deployment Strategies (Blue-Green, Canary)
- [ ] Feature Flags

#### Code Reusability and Modularity

- [ ] Creating Reusable Components
- [ ] Designing APIs for Extensibility
- [ ] Modular Architecture

#### Error Handling and Logging

- [ ] Effective Error Handling Strategies
- [ ] Logging Best Practices
- [ ] Monitoring and Alerting

#### Security Practices

- [ ] Secure Coding Guidelines
- [ ] Common Vulnerabilities (OWASP Top 10)
- [ ] Security Testing Tools

#### Documentation

- [ ] Writing Effective Technical Documentation
- [ ] API Documentation
- [ ] User Manuals and Guides

#### Tooling and Development Environment

- [ ] IDE Mastery and Productivity Tools
- [ ] Build Tools and Task Runners
- [ ] Containerization for Development Environments

#### Code Analysis and Metrics

- [ ] Cyclomatic Complexity
- [ ] Code Coverage
- [ ] Technical Debt Quantification

#### Cross-platform Development

- [ ] Writing Portable Code
- [ ] Platform-specific Considerations

#### Open Source Contribution

- [ ] Understanding Open Source Licenses
- [ ] Contributing to Open Source Projects
- [ ] Managing an Open Source Project

### Soft Skills and Project Management

#### Effective Communication

- [ ] Active Listening Techniques
- [ ] Clear and Concise Writing
- [ ] Presentation Skills for Technical Topics
- [ ] Giving and receiving feedback

#### Time Management and Productivity

- [ ] Prioritization Techniques (e.g., Eisenhower Matrix)
- [ ] Pomodoro Technique and Other Time-boxing Methods
- [ ] Managing Interruptions and Context Switching
- [ ] Personal Kanban and Task Management Systems

#### Problem-solving and Critical Thinking

- [ ] Root Cause Analysis Techniques
- [ ] Decision-making Frameworks
- [ ] Creative Problem-solving Methods
- [ ] Systems Thinking Approach

#### Mentoring and Knowledge Sharing

- [ ] Effective Mentoring Techniques
- [ ] Creating and Delivering Technical Workshops
- [ ] Building a Knowledge Base for the Team
- [ ] Pair Programming as a Learning Tool

#### Emotional Intelligence in the Workplace

- [ ] Self-awareness and Self-regulation
- [ ] Empathy in Team Interactions
- [ ] Conflict Resolution Strategies

#### Leadership Skills for Developers

- [ ] Leading Without Authority
- [ ] Influencing and Negotiation Skills
- [ ] Building and Motivating Teams

#### Agile Methodologies

- [ ] Scrum
  - [ ] Scrum Roles, Artifacts, and Events
  - [ ] Sprint Planning and Retrospectives
  - [ ] Backlog Refinement and Management
- [ ] Kanban
  - [ ] Kanban Principles and Practices
  - [ ] Visualizing Workflow and Limiting WIP
  - [ ] Continuous Improvement with Kanban
- [ ] Extreme Programming (XP)
- [ ] Lean Software Development
- [ ] Scaled Agile Framework (SAFe)

#### Estimation Techniques

- [ ] Story Points and Relative Estimation
- [ ] Planning Poker and Team Estimation Games
- [ ] T-shirt Sizing
- [ ] Affinity Estimation

#### Project Planning and Tracking

- [ ] Creating and Managing Product Backlogs
- [ ] Sprint Planning and Capacity Planning
- [ ] Burndown and Burnup Charts
- [ ] Velocity Tracking and Forecasting

#### Managing Technical Debt

- [ ] Identifying and Categorizing Technical Debt
- [ ] Strategies for Addressing Technical Debt
- [ ] Balancing new Features with Debt Repayment

#### Risk Management in Agile Projects

- [ ] Risk Identification and Assessment
- [ ] Mitigation Strategies in an Agile Context

#### Agile Metrics and KPIs

- [ ] Selecting Appropriate Metrics for Agile Teams
- [ ] Interpreting and Acting on Agile Metrics

#### Technical Writing and Documentation

- [ ] API Documentation
  - [ ] Best Practices for API Documentation
  - [ ] Tools for API Documentation (e.g., Swagger, Postman)
  - [ ] Versioning and Maintaining API Docs
- [ ] Architecture Decision Records (ADRs)
  - [ ] Writing Effective ADRs
  - [ ] Templates and Tools for ADRs
  - [ ] Maintaining and Referencing ADRs Over Time
- [ ] Technical Specifications
  - [ ] Writing Clear and Comprehensive Specs
  - [ ] Balancing Detail with Readability
- [ ] User Documentation
  - [ ] Creating User Guides and Manuals
  - [ ] Writing for Different Audience Levels
- [ ] Code Documentation
  - [ ] Inline Comments and Self-documenting Code
  - [ ] README Files and Project Documentation
- [ ] Technical Blogging
  - [ ] Writing Engaging Technical Blog Posts
  - [ ] Sharing Knowledge Through Case Studies

#### Team Collaboration and Communication

- [ ] Effective Remote Work Practices
  - [ ] Tools for Remote Collaboration
  - [ ] Asynchronous Communication Techniques
- [ ] Cross-functional Team Collaboration
  - [ ] Working Effectively with Designers, Product Managers, and Stakeholders
- [ ] Code Review Best Practices
  - [ ] Giving Constructive Feedback
  - [ ] Receiving and Implementing Feedback
- [ ] Meeting Facilitation
  - [ ] Running Effective Stand-ups and Retrospectives
  - [ ] Facilitating Technical Discussions and Decision-making

#### Personal Development Plans

- [ ] Setting and Achieving Professional Goals
- [ ] Continuous Learning Strategies for Developers

#### Team Retrospectives

- [ ] Facilitating Effective Retrospectives
- [ ] Implementing and Tracking Improvement Actions

#### Process Improvement

- [ ] Identifying Bottlenecks and Inefficiencies
- [ ] Implementing and Measuring Process Changes

#### Cost Estimations

- [ ] Project Cost Estimation
  - [ ] Estimating Development Time and Effort
  - [ ] Calculating Costs for New Services and Infrastructure
  - [ ] Estimating Operational Costs (OpEx)
  - [ ] Total Cost of Ownership (TCO) Analysis
- [ ] Architecture and Deployment Cost Analysis
  - [ ] Comparing Costs of Different Architectural Approaches
  - [ ] Cloud vs On-Premise Cost Comparisons
  - [ ] Estimating Scaling Costs
- [ ] Return on Investment (ROI) Calculations
  - [ ] Quantifying Benefits of Technical Initiatives
  - [ ] Cost-Benefit Analysis for New Technologies

#### Impact Estimation and Demonstration

- [ ] Measuring and Projecting Performance Improvements
- [ ] Estimating Business Impact of Technical Changes
- [ ] Creating Compelling Business Cases for Technical Projects

#### Stakeholder Management

- [ ] Identifying Key Stakeholders
- [ ] Tailoring Communication for Different Audiences

#### Reporting and Dashboards

- [ ] Creating Effective Technical Dashboards
- [ ] Visualizing Project Progress and Impact

#### Presenting Technical Concepts to Non-Technical Audiences

- [ ] Simplifying Complex Ideas
- [ ] Using Analogies and Real-World Examples

#### Demonstrating Value of Technical Work

- [ ] Linking Technical Achievements to Business Outcomes
- [ ] Showcasing Success Stories and Case Studies

#### Visibility Strategies for Development Teams

- [ ] Internal Tech Talks and Knowledge Sharing Sessions
- [ ] Contributing to Company-Wide Communications
- [ ] Participating in Cross-Functional Initiatives

#### Financial Aspects of Software Development

- [ ] Budgeting for Software Projects
  - [ ] Creating and Managing Project Budgets
  - [ ] Dealing with Budget Constraints
- [ ] Understanding Financial Statements
  - [ ] Basic Accounting for Developers
  - [ ] Reading and Interpreting Financial Reports
- [ ] Software Capitalization
  - [ ] Understanding When to Capitalize Software Development Costs
  - [ ] Implications of Capitalization on Project Management
